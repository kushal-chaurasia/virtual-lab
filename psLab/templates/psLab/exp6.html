{% extends 'psLab/basic.html'%}

{%block title%}Recursion {% endblock %}

{% block introduction %}
<!-- introduction content -->
<h4>Recursion</h4>
<p>Welcome to recursion. One of the most easiest things to code but really hard to debug! Recursion is a very powerful tool to solve problems. All loops(while, for , do while) can be simulated using recursion. Also the main step of the dynamic programming is recursion which is useful in solving many algorithmically difficult problems. Lets solve some problems now.</p>
<h5>Problem 1</h5>
<p>You are given scales for weighing loads. On the left side lies a single stone of known weight W &lt; 2N. You own a set of N different weights, weighing 1, 2, 4, ..., 2<sup>−1</sup> units of mass respectively. Determine how many possible ways there are of placing some weights on the sides of the scales, so as to balance them (put them in a state of equilibrium).</p>
<strong>Input Specification</strong>
<p>The input line contains two integers: N W, where N denotes the number of weights and W represents the weight to be placed on the left side.</p>
<strong>Output Specification</strong>
<p>Output must be a single integer denoting the number ways in which one can balance the weight W by placing weights on any side.</p>
<strong>Sample Input and Output</strong>
<p>Input: 2 4 <br>
    Output: 3 <br>
    Input: 5 10 <br>
    Output: 14
    </p>
<h5>Problem 2</h5>
<p>Given a weighing pan, n weights and a destination weight D, print “YES” or “NO” depending whether you can weight D using other weights given.</p>
<strong>Input Specification</strong>
<p>Input begins with numbers of weights n, then n values denoting mass of each weight and then in the end destination weight D.</p>
<strong>Output Specification</strong>
<p>As the output, print “YES” if it is possible to weight D, otherwise “NO”.</p>
<strong>Sample Input and Output</strong>
<p>Input: 3 1 3 4 2 <br>
    Output: YES <br>
    Input: 2 1 3 5 <br>
    Output: NO
    </p>

{%endblock%}

{% block theory %}
<!-- theory conteent -->
<h4>Theory</h4>
<hr>
<h5>Problem 1</h5>
<p>Recursion can be applied to a problem if the problem for the given input can be expressed as dependent upon the solution of the same problem for simpler inputs. One has to hardcode the solution for some simple cases, so that this recursion does not go on endlessly. Now, the given problem of expressing a weight(W) as a sum of other weights can be expressed as the problem of choosing one weight(w) such that it is not greater than W and then solving the same problem for the remaining weight W-w. For this particular problem, the solution can be expressed easily by choosing all the possible multiples(m) of a given unit, 2<sup>(i)</sup>, iteratively for all the values of m for which m*2<sup>(i)</sup>  is less than W, and subsequently solving the same problem for the remaining weight, W-w, and for multiples of weights for higher order. So, our recursion function would be needing 2 variable, one signifying multiples of which order of weight should be used this time and other signifying remaining weight to be accrued.</p>
<hr>
<h5>Problem 2</h5>
<p>Let us assume we have kept weight D on left pan. From amongst the N weights you can choose to keep some weights on left side and some weights on right side and we may not use some weights at all. Lets say we keep a total weight of w1 on left side and w2+D on right pan, then for balancing w1=w2+D.We keep track the difference between the two pans and if at any stage the difference of weights between two pans is 0 we report yes. Consider the i<sup>th</sup> weight and suppose the current difference between left pan and right pan is x. If x is 0 then yes we donot choose any weight and thus return 1. <br>
Otherwise we have three options
</p>
<p><strong>Option 1:</strong>  Put the i<sup>th</sup> weight on right pan.In which case the difference between left and right pan becomes x - weight[i]</p>
<p><strong>Option 2:</strong> Put the i<sup>th</sup> weight on left pan.In which case the difference between left and right pan becomes x + weight[i]</p>
<p><strong>Option 3:</strong>Donot put the i<sup>th</sup> weight on either pan.In which case the difference between left and right pan remains x.</p>
<strong>This gives the following Recursive Function :</strong>
<p>Let F(i,x) denotes whether it is possible to obtain a difference of x using the weights <br>
    w[i],w[i+1],...,w[n-1]. <br>
    Obviously, F(i,0) is 1, Otherwise <br>
    F(i,x) = F(i+1,x)||F(i+1,x-w[i])||F(i+1,x+w[i]); <br>
    F(i+1,x) corresponds to Option3. <br>
    F(i+1,x-w[i]) corresponds to Option1. <br>
    F(i+1,x+w[i]) corresponds to Option2.
    </p>
{% endblock %}

{% block objective %}
<!-- objective content -->
<h4>Objective</h4>
<p>To learn to solve problems related to Recursion using Computer Programming.</p>
{% endblock %}

{% block experiment %}
<!-- experiment content -->
<h4>Experiment</h4>
<p>To learn to solve problems related to Recursion using Computer Programming.</p>

{% endblock %}

{% block manual %}
<!-- software content -->
<h5>Manual</h5>
<p>For each problem you have to write a program in C or C++. Each question is evaluted on test cases. An answer is correct only when all the test cases are cleared.</p>
{% endblock %}

{% block procedure %}
<h4>Procedure</h4>
<p>Procedure for the experiment is as follows.</p>
<ul>
 <li>  Write the code for the problem or upload a solution. </li>
 <li> Press the i button get info about the problem which you have to solve. </li>
 <li> If you are finding it difficult to solve the solution, then you can use the 4 levels of          incresingly descriptive hints, but try to use minimum number of hints. </li>
 <li> Compile the code by pressing the compile button. </li>
 <li> If code is not compling then correct the error and/or warnings. </li>
 <li> To execute the code and see output, press the execute button. </li>
 </ul>
{%endblock%}